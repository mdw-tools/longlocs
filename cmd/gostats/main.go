// gostats scans Go source code and emits statistics about the length of lines, functions, and files, etc.
// This code was initially generated by ChatGPT, so naturally it didn't work at first.
// Thankfully, it appears that all the heavy lifting (parsing and math) was done correctly, it just forgot
// a few important details (like resolving relative directories passed from the command line, and error checking).
// https://chatgpt.com/share/69575150-9128-800a-a8c3-9c042d91fae6
package main

import (
	"bufio"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

var Version = "dev"

const topN = 5

type LocatedValue struct {
	Value int
	File  string
	Line  int
}

type Stats struct {
	LineLengths       []int
	FileLengths       []int
	FuncLengths       []int
	FuncArgCounts     []int
	StructFieldCounts []int

	LineLengthLocs       []LocatedValue
	FileLengthLocs       []LocatedValue
	FuncLengthLocs       []LocatedValue
	FuncArgCountLocs     []LocatedValue
	StructFieldCountLocs []LocatedValue
}

func main() {
	log.SetFlags(log.Lshortfile | log.Lmicroseconds)

	flags := flag.NewFlagSet(fmt.Sprintf("%s @ %s", filepath.Base(os.Args[0]), Version), flag.ExitOnError)
	flags.Usage = func() {
		_, _ = fmt.Fprintf(flags.Output(), "Usage of %s:\n", flags.Name())
		_, _ = fmt.Fprintf(flags.Output(), "%s [args ...]\n", filepath.Base(os.Args[0]))
		_, _ = fmt.Fprintln(flags.Output(), "Supply paths to Go source code in non-flag arguments. ")
		_, _ = fmt.Fprintln(flags.Output(), "Provided paths will be scanned and various statistics will be emitted. ")
		flags.PrintDefaults()
	}
	_ = flags.Parse(os.Args[1:])

	roots := flags.Args()
	if len(roots) == 0 {
		roots = []string{"."}
	}

	stats := &Stats{}
	fset := token.NewFileSet()

	for _, root := range roots {
		root, err := filepath.Abs(root)
		if err != nil {
			log.Fatal(err)
		}
		err = filepath.WalkDir(root, func(path string, d os.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() {
				if d.Name() == ".git" {
					return filepath.SkipDir
				}
				if d.Name() == "vendor" || strings.HasPrefix(d.Name(), ".") {
					return filepath.SkipDir
				}
				return nil
			}
			if strings.HasSuffix(path, ".go") {
				processFile(fset, path, stats)
			}
			return nil
		})
		if err != nil {
			log.Panic(err)
		}
	}

	printStats("Line lengths (chars)", stats.LineLengths)
	printStats("File lengths (lines)", stats.FileLengths)
	printStats("Function lengths (lines)", stats.FuncLengths)
	printStats("Function argument counts", stats.FuncArgCounts)
	printStats("Struct field counts", stats.StructFieldCounts)

	writeOutliers("outliers_line_lengths.txt", stats.LineLengthLocs)
	writeOutliers("outliers_file_lengths.txt", stats.FileLengthLocs)
	writeOutliers("outliers_function_lengths.txt", stats.FuncLengthLocs)
	writeOutliers("outliers_function_args.txt", stats.FuncArgCountLocs)
	writeOutliers("outliers_struct_fields.txt", stats.StructFieldCountLocs)
}

func processFile(fset *token.FileSet, path string, stats *Stats) {
	log.Println("processing:", path)
	file, err := os.Open(path)
	if err != nil {
		return
	}
	defer func() { _ = file.Close() }()

	scanner := bufio.NewScanner(file)
	line := 1
	lineCount := 0
	for scanner.Scan() {
		l := len(scanner.Text())
		stats.LineLengths = append(stats.LineLengths, l)
		stats.LineLengthLocs = append(stats.LineLengthLocs, LocatedValue{
			Value: l,
			File:  path,
			Line:  line,
		})
		line++
		lineCount++
	}
	stats.FileLengths = append(stats.FileLengths, lineCount)
	stats.FileLengthLocs = append(stats.FileLengthLocs, LocatedValue{
		Value: lineCount,
		File:  path,
		Line:  1,
	})

	astFile, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	if err != nil {
		return
	}

	ast.Inspect(astFile, func(n ast.Node) bool {
		switch x := n.(type) {

		case *ast.FuncDecl:
			start := fset.Position(x.Pos()).Line
			end := fset.Position(x.End()).Line
			length := end - start + 1

			stats.FuncLengths = append(stats.FuncLengths, length)
			stats.FuncLengthLocs = append(stats.FuncLengthLocs, LocatedValue{
				Value: length,
				File:  path,
				Line:  start,
			})

			argCount := 0
			if x.Type.Params != nil {
				for _, f := range x.Type.Params.List {
					if len(f.Names) == 0 {
						argCount++
					} else {
						argCount += len(f.Names)
					}
				}
			}
			stats.FuncArgCounts = append(stats.FuncArgCounts, argCount)
			stats.FuncArgCountLocs = append(stats.FuncArgCountLocs, LocatedValue{
				Value: argCount,
				File:  path,
				Line:  start,
			})

		case *ast.TypeSpec:
			if s, ok := x.Type.(*ast.StructType); ok {
				count := 0
				for _, f := range s.Fields.List {
					if len(f.Names) == 0 {
						count++
					} else {
						count += len(f.Names)
					}
				}
				line := fset.Position(x.Pos()).Line
				stats.StructFieldCounts = append(stats.StructFieldCounts, count)
				stats.StructFieldCountLocs = append(stats.StructFieldCountLocs, LocatedValue{
					Value: count,
					File:  path,
					Line:  line,
				})
			}
		}
		return true
	})
}

func printStats(name string, values []int) {
	if len(values) == 0 {
		return
	}
	sort.Ints(values)

	fmt.Printf("\n== %s ==\n", name)
	fmt.Printf(
		"count=%d min=%d p50=%d p75=%d p90=%d p95=%d p99=%d max=%d\n",
		len(values),
		values[0],
		percentile(values, 0.50),
		percentile(values, 0.75),
		percentile(values, 0.90),
		percentile(values, 0.95),
		percentile(values, 0.99),
		values[len(values)-1],
	)
}

func percentile(sorted []int, p float64) int {
	idx := int(float64(len(sorted)-1) * p)
	return sorted[idx]
}

func writeOutliers(filename string, values []LocatedValue) {
	if len(values) == 0 {
		return
	}
	sort.Slice(values, func(i, j int) bool {
		return values[i].Value > values[j].Value
	})

	f, err := os.CreateTemp("", "*-"+filename)
	if err != nil {
		log.Println(err)
	}
	defer func() { _ = f.Close() }()

	log.Println("Emitting stats to:", f.Name())

	w := bufio.NewWriter(f)
	defer func() { _ = w.Flush() }()

	limit := topN
	if len(values) < limit {
		limit = len(values)
	}
	for i := 0; i < limit; i++ {
		v := values[i]
		_, _ = fmt.Fprintf(w, "%d\t%s:%d\n", v.Value, v.File, v.Line)
	}
}
